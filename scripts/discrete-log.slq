import bitLength, decToBin;
import uniformSuperposition;

// Source: https://github.com/eth-sri/silq/blob/master/test/qft.slq
def QFT[n:!ℕ](ψ: uint[n])mfree: uint[n]{
	for k in [0..n div 2){						// Performing operations on the first half of qubits
		(ψ[k],ψ[n-k-1]) := (ψ[n-k-1],ψ[k]);		// Swapping opposite qubits
	}
	for k in [0..n){
		ψ[k] := H(ψ[k]);
		for l in [k+1..n){
			if ψ[k] && ψ[l]{
				phase(2·π·2^(k-l-1));
			}
		}
	}
	return ψ;
}

// Unitary transformation |x⟩ |y⟩ |0⟩  >  |x⟩ |y⟩ |(b^x)(a^y)⟩
def unit[n:!ℕ](const a : uint[n], const b : uint[n], g : !ℕ, x : !ℕ, n : !ℕ)lifted : uint[n] { 
    return (decToBin(n,g)^a)*(decToBin(n,x)^(-b)) as uint[n];
}


def discreteLog(gen : !ℕ, mod : !ℕ, x : !ℕ): !ℕ{
	n := bitLength(mod) : !ℕ;

	// Uniform superposition prerequisite
	r := ceil(log(n)/log(2)) coerce !ℕ;

	// Initialize registers
	reg_a := uniformSuperposition(n,r) coerce uint[n];
	reg_b := uniformSuperposition(n,r) coerce uint[n];
	reg_c := 0:int[n];

	dump();

	reg_c := unit(reg_a, reg_b, gen, x, n);
	
	reg_a := QFT(reg_a);
	reg_b := QFT(reg_b);

	// DEBUG (change later)
	measure(reg_a);
	measure(reg_b);

	return(false);
}

def main(){
    print(discreteLog(13, 11, 9));
}