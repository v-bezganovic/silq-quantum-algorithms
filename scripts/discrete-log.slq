def phaseQ[n:!â„•](const Ï†: uint[n])mfree{
	for i in [0..n){ if Ï†[i]{ phase(2Â·Ï€Â·2^i/2^n); } }
}

def QFT[n:!â„•](Ïˆ: uint[n])mfree: uint[n]{
	for k in [0..n){
		j:=n sub 1 sub k;
		Ïˆ[j] := H(Ïˆ[j]); // Ïˆ'[j] = 1/âˆš2(|0âŸ©+expi(2Ï€Â·2^kÂ·(Ïˆ&2^j)/2^n)|1âŸ©)
		if Ïˆ[j]{ phaseQ(2^kÂ·(ÏˆâŠ•2^j)); }// Ïˆ''[j] = 1/âˆš2(|0âŸ©+expi(2Ï€Â·2^kÂ·Ïˆ/2^n)|1âŸ©)
	}
	for k in [0..n div 2){
		(Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]);
	}
	return Ïˆ;
}

// Unitary transformation
def unit(const x : uint[1], a : !â„•, b : !â„•, coef1 : !â„•, coef2 : !â„•) : ğ”¹ { 
    return x[2] != (b^coef1 * a^coef2);
}

def discreteLog(a : !â„•, b : !â„•, r : !â„•) : !â„•{

    // Initialize state
    qubits := vector(3, 0:uint[1]);

    // Apply QFT on first two qubits
	qubits[0] := QFT[1](qubits[0]);
	qubits[1] := QFT[1](qubits[1]);

	coef1 := measure(qubits[0]) as !â„•;
	coef2 := measure(qubits[1]) as !â„•;

	qubits[2] := unit(qubits[2], a, b, coef1, coef2);

    return;
}

def main(){
    print(discreteLog());
}