import random;

// Current algorithm's limit - array length of 30
arr_length := 30 : !â„•;
ar_length_bits := 5 : !â„•;

def generate_Subset(k : !â„•, arr : !â„•[]) : !â„•[]{
	subset := vector(k, 0:!â„•);

	for i in [0..k){
		element_index := randomInt(ar_length_bits) as uint[ar_length_bits]; 
		element_index_meas := measure(element_index);
    	subset[i] = arr[element_index_meas];
  	}

    return subset;
} 


def generate_Lists(k : !â„•, subset : !â„•[], f : !â„• !â†’ !â„•) : (!â„•[] x !â„•[]){
	output_list := vector(k, 0:!â„•);
	input_list := vector(k, 0:!â„•);
	
	for i in [0..k){
		output_list[i] = f(subset[i]);
		input_list[i] = subset[i];
  	}
	
	return (output_list, input_list);
}


def check_Doubles(k : !â„•, output_list : !â„•[], input_list : !â„•[]) : (!â„• x !â„•){
	for i in [0..k){
		for j in [i+1..k){
			if output_list[j] == output_list[i] && input_list[j] != input_list[i]{
				return (input_list[i], input_list[j]);
			} 
		}
	}
	return (0, 0);
}


// Source: https://github.com/eth-sri/silq.git
def grover[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!â„•{
	nIterations:=floor(Ï€/(4Â·asin(2^(-n/2))));
	cand:=0:uint[n];
    for k in [0..n){ cand[k]:=H(cand[k]); }
	for k in [0..nIterations){
		if f(cand){ phase(Ï€); }
		cand:=groverDiffusion(cand);
	}
	return measure(cand) as !â„•;
}


// Source: https://github.com/eth-sri/silq.git
def groverDiffusion[n:!â„•](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(Ï€); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}



def main(){
    // Initialize an array of elements (hardcoded)
    array := [14, 15, 11, 3, 25, 57, 4, 6, 2, 67, 87, 5, 7, 46, 9, 20, 18, 1, 13, 56, 89, 100, 49, 34, 300, 900, 78, 43, 32, 8] as !â„•[];

    // Set cardinality of a random subset
    k := 5 : !â„•;

	// Generate random subset
	subset := generate_Subset(k, array) as !â„•[];

	// Define test function for collision input
	def func (x:!â„•)mfree: !â„•{ return x % 7 };

	// Generate output list
	(outputs, inputs) := generate_Lists(k, subset, func);
	print(outputs, inputs);										// DEBUG

	// Collision elements
	collision1 := 0 : !â„•;
	collision2 := 0 : !â„•;

	if (check_Doubles(k, outputs, inputs) == (0, 0)){			// Collision not detected upon initial observation
		print(1);												// DEBUG


	}

	else {(collision1,collision2) = check_Doubles(k, outputs, inputs);}

	// Define oracle for collision detection
    //f := Î»(x : uint[ar_length_bits]) lifted : ğ”¹ { 
    //    return x <= solution;
    //};

	print(collision1, collision2);
}