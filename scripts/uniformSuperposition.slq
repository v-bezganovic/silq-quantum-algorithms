import decToBin, bitLength;

def uniformSuperposition (m : !â„•, n : !â„•) : ð”¹^n{
    // Initialize vector of qubits to operate on
    qubits := vector(n, 0:ð”¹);

    // Generate binary representation of the given number m
    len := bitLength(m);
    bin := decToBin(len,m);
    
    // DEBUG
    for i in [0..len){
        //print(bin[i]);
    }

    // Generate reverse binary representation
    rev_bin := 0 : !uint[len];
    k := 0 : !â„•;
    for i_1 in [0..len){
        if bin[i_1]{k = k + 1;}
        rev_bin[i_1] = X(bin[i_1]); 
    }

    // Flip the resulting representation
    for bit in [0..len div 2){
        (rev_bin[bit],rev_bin[len-bit-1]) = (rev_bin[len-bit-1],rev_bin[bit]);
    }

    // DEBUG
    for i in [0..len){
        print(rev_bin[i]);
    }

    // Detect locations of 1
    locs := vector(k, 0:!â„•);
    cur_slot := 0 : !â„•;

    //dump();

    for i_2 in [0..len){
        if rev_bin[i_2]{    // out of bounds
            dump();
            locs[cur_slot] = i_2;
            cur_slot = cur_slot + 1; 
        }
    }

    // Apply X to qubits under loc_1...loc_k
    for i_3 in [1..k){
        qubits[locs[i_3]] = X(qubits[locs[i_3]]);
    }

    // Apply Hadamard to qubits before l_0
    if locs[0] > 0 {
        for i_4 in [0..locs[0]){
            qubits[i_4] := H(qubits[i_4]);
        }
    }

    // Apply rotation Y
    M_m := 2^locs[0];
    qubits[locs[1]] := rotY(-2*acos(sqrt(M_m div m)), qubits[locs[1]]);

    q1 := dup(qubits[locs[1]]);
    // Apply conditioned Hadamard
    if !q1{
        for i_5 in [locs[0]..locs[1]-1){
            qubits[i_5] := H(qubits[i_5]); 
        }
    }
    forget(q1 = qubits[locs[1]]);

    // Apply cyclic rotation and Hadamard operators
    for i_6 in [1..k-1){
        qub1 := dup(qubits[locs[i_6]]);
        if !qub1{
            qubits[locs[i_6+1]] := rotY(-2*acos(sqrt((2^locs[i_6]) div (m - M_m))), qubits[locs[i_6+1]]);
        }
        forget(qub1 = qubits[locs[i_6]]);
        qub2 := dup(qubits[locs[i_6+1]]);
        if !qub2{
            for j_1 in [locs[i_6]..locs[i_6+1]-1){
                qubits[j_1] := H(qubits[j_1]);
            }
        }
        forget(qub2 = qubits[locs[i_6+1]]);
        M_m = M_m + 2^locs[i_6];
    }

    dump();

    return qubits;
} 

def main(){
    qubits := uniformSuperposition(8, 10); 
    measure(qubits);
}