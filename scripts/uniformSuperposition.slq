import decToBin, bitLength;

def uniformSuperposition (m : !ℕ, n : !ℕ) : 𝔹^n{
    // Initialize vector of qubits to operate on
    qubits := vector(n, 0:𝔹);

    // Generate binary representation of the given number m
    len := bitLength(m);
    bin := decToBin(len,m);
    
    // DEBUG
    for i in [0..len){
        print(bin[i]);
    }

    // Generate reverse binary representation
    rev_bin := 0 : !uint[len];
    k := 0 : !ℕ;
    for i in [0..len){
        if bin[i]{k = k + 1;}
        rev_bin[i] = X(bin[i]); 
    }

    // Detect locations of 1
    locs := vector(k, 0:!ℕ);
    temp := 0 : !ℕ;

    for i in [0..len){
        if rev_bin[i]{
            locs[temp] = i;
            temp = temp + 1; 
        }
    }

    // Apply X to qubits under loc_1...loc_k
    for i in [1..k){
        qubits[locs[i]] = X(qubits[locs[i]]);
    }

    // Apply Hadamard to qubits before l_0
    if locs[0] > 0 {
        for i in [0..locs[0]){
            qubits[i] := H(qubits[i]);
        }
    }

    // Apply rotation Y
    M_m := 2^locs[0];
    qubits[locs[1]] := rotY(-2*acos(sqrt(M_m div m)), qubits[locs[1]]);

    q1 := dup(qubits[locs[1]]);
    // Apply conditioned Hadamard
    if !q1{
        for i in [locs[0]..locs[1]-1){
            qubits[i] := H(qubits[i]); 
        }
    }
    forget(q1 = qubits[locs[1]]);

    // Apply cyclic rotation and Hadamard operators
    for i in [1..k-1){
        qub1 := dup(qubits[locs[i]]);
        if !qub1{
            qubits[locs[i+1]] := rotY(-2*acos(sqrt((2^locs[i]) div (m - M_m))), qubits[locs[i+1]]);
        }
        forget(qub1 = qubits[locs[i]]);
        qub2 := dup(qubits[locs[i+1]]);
        if !qub2{
            for j in [locs[i]..locs[i+1]-1){
                qubits[j] := H(qubits[j]);
            }
        }
        forget(qub2 = qubits[locs[i+1]]);
        M_m = M_m + 2^locs[i];
    }

    return qubits;
} 

def main(){
    qubits := uniformSuperposition(8, 10); 
    measure(qubits);
}